
Michal's way: reducer produces the function with an array (or function). Create state works with it (or reducers may be subscoped again).

blueprint:
  stateScope: 'something',

functions:
set in path ('some.path' or ['some', 'path'])
get in path ('some.path' or ['some', 'path'])

  make it dependent on if Immutable is present. If present, it will use it's functions, otherwise our own.


RxR: easier state and actions/messages management for React

* inspired by Redux. When you know how to write Redux app, RxR will be easy (easier ;). Many functional code may stay intact or needs just small changes.
* powered by RxJS. Functional and reactive programming with streams has huge benefits. Let's harness them into React to make it trully reactive.

I'd like to write more benefits but these two are most important, so let them shine.

--

IT'S ALL ABOUT PRESENTATION!!! - this will drive visibility and usability

Show simple app - in a whole. Our clients app (put it into the examples)? Make it as Redux, make it as RxR.

Show the power of blueprint:
  clear message streams
  clear state
  same Provider and ConnectWithState
  monitor
  power of RxJS (retry, debounce)

Extras:
  Compose blueprints (for more complex applications)
    Highlight:
    - composability (distribute parts)
      - Redux is about pulling constants, having global dispatcher... it has no good composability
    - separation of concerns
    - independent monitors (and more)


--

test:
is-immutable?
is-immutable-present?

utility:
  setScopedState
  getScopedState (is it needed?)

--

DO THIS:

Then make the blueprint = Subjects, monitors, reducers and state.
  reducers will be scoped (generate array)
  createState will work with scoped

Test it (that it works)

Do composeBlueprints
- app.users.streams.login
- app.users.stateS
